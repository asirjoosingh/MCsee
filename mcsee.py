#!/usr/bin/env python

import os
import numpy as np
from random import Random
from subprocess import Popen,PIPE
from utils import findnearest
from convfactors import *


class ElScattCrossSec(object):
  """
  Class for electron elastic scattering cross section data

  Class initialized with the filename of a data file, e.g. ElScattCrossSec([file])
  where [file] contains elastic scattering cross section data generated by the
  NIST database GUI

  Attributes:
      filestring: Filename of data file
           atnum: Atomic number (currently only Nickel recognized to calculate emfp)
          energy: Energy corresponding to cross section data
     totcrosssec: Total elastic scattering cross section (integrated over angle)
            data: Elastic scattering cross section as a function of angle
      cumintdata: Cumulative integral of elastic scattering cross section (trapezoid)
            npts: Number of data points
            emfp: Calculated elastic mean free path (Angstrom)

  Methods:
     nintegrate: Integrates elastic cross section data between two angles (trapezoid)

  Static methods:
     findemfp: For an array of ElScattCrossSec instances, finds elastic mean free path for a given energy
  """

  def __init__(self,filestring):
    try:
      inp=open(filestring,"r")
      lines=inp.readlines()
      inp.close()
    except:
      raise IOError("File " + filestring + " not found")
    self.filestring=filestring
    self.atnum=int(Popen("grep 'Atomic number' " + filestring,stdout=PIPE,shell=True).communicate()[0].strip().split()[-1])
    self.energy=int(Popen("grep 'Energy' " + filestring,stdout=PIPE,shell=True).communicate()[0].strip().split()[-2])
    self.totcrosssec=float(Popen("grep 'Total cross section' " + filestring,stdout=PIPE,shell=True).communicate()[0].strip().split()[-2])
    self.data=[]
    self.cumintdata=[] # stores cumulative integral from 0->theta cross_section(theta) * sin(theta) * dtheta (corresponding angle indexed in same order in self.data)
    done=False
    while not done:
      linesplit=lines[0].strip().split()
      del lines[0]
      if len(linesplit) >= 2 and linesplit[0] == "Angle" and linesplit[1] == "theta":
       done=True
      if lines == []:
       done=True
       raise IOError("Could not process data in " + filestring)
    del lines[0]
    del lines[0]
    cumint=0.
    done=False
    while not done:
      linesplit=lines[0].strip().split()
      del lines[0]
      ang=float(linesplit[0])*np.pi/180.
      val=float(linesplit[1])
      self.data.append((ang,val))
      if len(self.cumintdata) > 0:
       cumint+=0.5*(ang-ang0)*(np.sin(ang)*val+np.sin(ang0)*val0)
      self.cumintdata.append(cumint)
      ang0=ang
      val0=val
      if lines == []:
       done=True
    self.npts=len(self.data)
    if self.atnum == 28: # Nickel
     mass=58.6934 # amu=g/mol
     dens=8.908 # g/cm3
    self.emfp=1.0/(self.totcrosssec*dens/mass*0.602214*(bohr2ang)**3)
    return

  def __repr__(self):
    return "<class ElScattCrossSec object: %r>"%(self.filestring)

  def __str__(self):
    outp="""
    Instance of ElScattCrossSec class:
    ------------------------
      File          = %s
      Atomic Number = %-4d
      Energy        = %-4d
      # Data Points = %-4d
    ------------------------
    """%(self.filestring,self.atnum,self.energy,self.npts)
    return outp

  def nintegrate(self,a,b):
    intsum=0.
    for i in range(self.npts-1):
      if self.data[i+1][0] > b:
       break
      else:
       if self.data[i][0] >= a:
        intsum+=0.5*(self.data[i+1][0]-self.data[i][0])*(np.sin(self.data[i+1][0])*self.data[i+1][1]+np.sin(self.data[i][0])*self.data[i][1])
    return intsum

  @staticmethod
  def findemfp(ecsarr,en):
    enarr=np.zeros(len(ecsarr))
    for i in range(len(ecsarr)):
      enarr[i]=ecsarr[i].energy
    ecsind,enfound=findnearest(enarr,en)
    return ecsind,ecsarr[ecsind].emfp


class InelScattCrossSec(object):
  """
  Class for electron inelastic scattering cross section data

  Class initialized with the filename of a data file, e.g. InelScattCrossSec([file])
  where [file] contains inelastic scattering cross section data generated by the
  NIST database GUI

  Attributes (set by init):
     filestring: Filename of data file
          atnum: Atomic number (currently only Nickel recognized)
       atweight: Atomic weight
        density: Atomic number density
       imfpdata: List of tuples containing imfp values (A) as a function of energy (eV)
       energies: List of energy values for which imfp data is tabulated (eV)
       nimfppts: Number of en/imfp values

  Attributes (set by readicsdata):
            Emin: Minimum energy value for differential cross section data (eV)
            Emax: Maximum energy value for differential cross section data (eV)
              NE: Number of energy values for which differential cross section data exists
           NdelE: Number of energy difference values for which differential cross section data exists
         icsdata: Inelastic differential scattering cross section as a function of energy (E) and energy diff (delE)
      cumintdata: Stores for each E the cumulative integral from 0->delE cross_section(delE) * delE
     totcrosssec: Total inelastic scattering cross section (integrated over delE) for each E
            wmin: Minimum hw for which electron loss function exists (Hartree)
            wmax: Maximum hw for which electron loss function exists (Hartree)
              Nw: Number of frequencies for which differential cross section data exists
            qmin: Minimum q for which electron loss function exists (bohr^-1)
            qmax: Maximum q for which electron loss function exists (bohr^-1)
              Nq: Number of q values for which differential cross section data exists
         wcoords: Nw-dim list of w values for which ELF is tabulated
         qcoords: Nq-dim list of q values for which ELF is tabulated
           elfqw: Electron loss function tabulated over (q,w)
          maxang: Maximum inelastic scattering angle past which a working integral is zero (auxiliary quantity)

  Methods:
          findimfp: Finds IMFP value for given energy
       readicsdata: Tabulates differential inelastic cross section data and energy loss function data from files
        getEcoords: Constructs list of energy values available
     getdelEcoords: Constructs list of energy difference values available
        getwcoords: Constructs list of hw values available
        getqcoords: Constructs list of q values available
      finddcsangle: Working routine searching for an angle corresponding to a random integrated cross section
  """

  def __init__(self,filestring):
    try:
      inp=open(filestring,"r")
      lines=inp.readlines()
      inp.close()
    except:
      raise IOError("File " + filestring + " not found")
    self.filestring=filestring
    elem=Popen("grep -A 1 'ELEMENT' " + filestring,stdout=PIPE,shell=True).communicate()[0].strip().split("\n")[1].strip()
    if elem == "Ni":
     self.atnum=28
    self.atweight=float(Popen("grep 'ATOMIC WEIGHT' " + filestring,stdout=PIPE,shell=True).communicate()[0].strip().split()[-1])
    self.density=float(Popen("grep 'DENSITY' " + filestring,stdout=PIPE,shell=True).communicate()[0].strip().split()[-2])
    self.imfpdata=[]
    self.energies=[]
    done=False
    while not done:
      linesplit=lines[0].strip().split()
      del lines[0]
      if len(linesplit) >= 2 and linesplit[0] == "Energy" and linesplit[1] == "IMFP":
       done=True
      if lines == []:
       done=True
       raise IOError("Could not process data in " + filestring)
    del lines[0]
    del lines[0]
    done=False
    while not done:
      linesplit=lines[0].strip().split()
      del lines[0]
      en=float(linesplit[0]) # Read in as eV
      val=float(linesplit[1])*ang2bohr # Read in as A, store as au
      self.imfpdata.append((en,val))
      self.energies.append(en)
      if lines == []:
       done=True
    self.nimfppts=len(self.imfpdata)
    return

  def __repr__(self):
    return "<class InelScattCrossSec object: %r>"%(self.filestring)

  def __str__(self):
    outp="""
    Instance of InelScattCrossSec class:
    ------------------------
      File          = %s
      Atomic Number = %-4d
      # Data Points = %-4d
    ------------------------
    """%(self.filestring,self.atnum,self.nimfppts)
    return outp

  def findimfp(self,en):
    icsind,enfound=findnearest(self.energies,en)
    return self.imfpdata[icsind][1]

  def readicsdata(self,filestring1,filestring2,Efermi):
    try:
      inp1=open(filestring1,"r")
      lines1=inp1.readlines()
      inp1.close()
    except:
      raise IOError("File " + filestring1 + " not found")
    try:
      inp2=open(filestring2,"r")
      lines2=inp2.readlines()
      inp2.close()
    except:
      raise IOError("File " + filestring2 + " not found")
# Get differential data
    self.Emin=float(lines1[0].strip())*ev2au
    del lines1[0]
    self.Emax=float(lines1[0].strip())*ev2au
    del lines1[0]
    self.NE=int(len(lines1))
    self.NdelE=int(len(lines1[0].strip().split()))
    self.icsdata=np.zeros((self.NE,self.NdelE))
    self.cumintdata=np.zeros((self.NE,self.NdelE)) # stores for each E the cumulative integral from 0->delE cross_section(delE) * delE (corresponding delE indexed in same order in self.icsdata[E,:])
    self.totcrosssec=np.zeros(self.NE)
    Ecoords=self.getEcoords()
    for i in range(self.NE):
      delEcoords=self.getdelEcoords(Ecoords[i])
      linesplit=lines1[0].strip().split()
      del lines1[0]
      cumint=0.
      for j in range(self.NdelE):
        val=float(linesplit[j])
        self.icsdata[i,j]=val
        if j > 0:
         cumint+=0.5*(delEcoords[j]-delEcoords[j-1])*(val+val0)
        self.cumintdata[i,j]=cumint
        val0=val
        if delEcoords[j] <= (Ecoords[i]-Efermi*ev2au):
         self.totcrosssec[i]=cumint
# Get ELF(q,w) data
    wmin=float(lines2[0].strip())*ev2au # Read in eV, convert to Eh
    del lines2[0]
    wmax=float(lines2[0].strip())*ev2au # Read in eV, convert to Eh
    del lines2[0]
    qmin=float(lines2[0].strip())*bohr2ang # Read in A^-1, convert to a0^-1
    del lines2[0]
    qmax=float(lines2[0].strip())*bohr2ang # Read in A^-1, convert to a0^-1
    del lines2[0]
    self.wmin=wmin
    self.wmax=wmax # Temp
    self.qmin=qmin
    self.qmax=qmax # Temp
    self.Nw=int(len(lines2)) # Temp
    self.Nq=int(len(lines2[0].strip().split())) # Temp
    self.wcoords=self.getwcoords() # Temp
    self.qcoords=self.getqcoords() # Temp
    wind,wval=findnearest(self.wcoords,self.Emax) # Find last index of input table needed
    if (self.Emax > wval) and (wind < self.Nw): # Round up to ensure table is complete for all transitions
     wind+=1
     wval=self.wcoords[wind]
    self.wmax=wval
    self.Nw=wind+1
    self.wcoords=self.getwcoords()
    qind,qval=findnearest(self.qcoords,np.sqrt(2.*self.wmax)) # Find last index of input table needed
    if qind < self.Nq: # Round up to ensure table is complete for all transitions
     qind+=1
     qval=self.qcoords[qind]
    self.qmax=qval
    self.Nq=qind+1
    self.qcoords=self.getqcoords()
    self.elfqw=np.zeros((self.Nw,self.Nq))
    for i in range(self.Nw):
      linesplit=lines2[0].strip().split()
      del lines2[0]
      for j in range(self.Nq):
        val=float(linesplit[j])
        self.elfqw[i,j]=val
# Find maximum inelastic scattering angle to save loop iterations later
    a=np.sqrt(self.Emax*(self.Emax-self.wmin))
    b=4.*self.Emax-2.*self.wmin
    c=-4.*a
    maxang=-1 # degrees (int)
    done=False
    while not done:
      maxang+=1
      ang=maxang*np.pi/180.
      q=np.sqrt(b+c*np.cos(ang))
      if (q > self.qmax) or (maxang == 180):
       done=True
    self.maxang=maxang
    return

  def finddcsangle(self,E,delE,wind,rand):
    deltheta=1.*np.pi/180. # grid in increments of 1 deg (consistent with elastic scattering)
    a=np.sqrt(E*(E-delE))
    b=4.*E-2.*delE
    c=-4.*a
    d=1./(np.pi*np.pi*E)
    ang0=0.
    val0=0.
    cumint=0.
    cumintarr=np.zeros((self.maxang+1))
    for i in range(1,self.maxang+1):
      ang=i*deltheta
      q=np.sqrt(b+c*np.cos(ang))
      qind,qval=findnearest(self.qcoords,q)
      val=d*self.elfqw[wind,qind]*a/(q*q)
      cumint+=0.5*deltheta*(val*np.sin(ang)+val0*np.sin(ang0))
      cumintarr[i]=cumint
    ind,val=findnearest(cumintarr,rand*cumintarr[-1])
    theta=ind*deltheta
#    print cumintarr[-1],rand*cumintarr[-1],ind,val,theta*180/pi
    return theta

  def getEcoords(self):
    Estep=(self.Emax-self.Emin)/(self.NE-1)
    coords=[]
    for i in range(self.NE):
      coords.append(self.Emin+i*Estep)
    return coords

  def getdelEcoords(self,en):
    delEmax=en
    delEstep=delEmax/(self.NdelE-1)
    coords=[]
    for i in range(self.NdelE):
      coords.append(i*delEstep)
    return coords

  def getwcoords(self):
    wstep=(self.wmax-self.wmin)/(self.Nw-1)
    coords=[]
    for i in range(self.Nw):
      coords.append(self.wmin+i*wstep)
    return coords

  def getqcoords(self):
    qstep=(self.qmax-self.qmin)/(self.Nq-1)
    coords=[]
    for i in range(self.Nq):
      coords.append(self.qmin+i*qstep)
    return coords


class Electron(object):
  """
  Class for electrons whose trajectories are being simulated

  Class initialized with the properties listed below under Attributes (init)
  as well as an array ecsdata containing ElScattCrossSec instances and
  an InelScattCrossSec instance icsinst

  Attributes (init):
      order: Integer describing order in generation by collision (0=primary, 1=initial secondary, ...)
     energy: Energy in eV
     coords: Cartesian coordinates (a0)
     vtheta: Angle from positive z-axis in direction of velocity relative to current coordinates
       vphi: Angle from positive x-axis in direction of velocity relative to current coordinates

  Attributes (set):
          vdirec: Unit vector in direction of velocity (Cartesian) relative to current coordinates
     transmitted: Boolean specifying whether electron has been transmitted from material
         stopped: Boolean specifying whether electron has been stopped in material
            emfp: Elastic mean free path (Angstrom)
            imfp: Inelastic mean free path (Angstrom)
             mfp: Total mean free path (Angstrom)

  Methods:
            getmfpdata: Obtain MFP data given energy
          updateenergy: Update energy (also updates MFP data) and check for stopped electron
          updatecoords: Update coords with incremental coordinates provided
     updatevdirecpolar: Update vphi,vtheta,vdirec with incremental angles provided
         checktransmit: Check for electron transmission based on Fermi energy, work fn and random num,
                        updates coordinates, velocities and energy based on transmission or reflection

  Static methods:
     prune: Dummy routine used for filtering arrays of Electron instances
  """

  def __init__(self,order,energy,coords,vtheta,vphi,ecsdata,icsinst):
    self.order=order          # intr describing order in generation by collision (0=primary, 1=initial secondary, ...)
    self.energy=energy        # energy in eV
    self.coords=np.zeros(3)   # coordinates (Cartesian)
    self.coords[:]=coords[:]
    self.vtheta=0.            # angle from positive z-axis in direction of velocity relative to current coordinates
    self.vphi=0.              # angle from positive x-axis in direction of velocity relative to current coordinates
    self.vdirec=np.zeros(3)   # unit vector in direction of velocity (Cartesian) relative to current coordinates
    self.updatevdirecpolar(vtheta,vphi)
    self.transmitted=False
    self.stopped=False
    self.getmfpdata(ecsdata,icsinst)
    return

  def __str__(self):
    infostr="""
    Instance of Electron class:
    -------------------------------------------
      Order          = %4d
      Energy (eV)    = %8.2f
      Coords (a0)    = (%6.2f,%6.2f,%6.2f)
      Velocity Direc = (%6.2f,%6.2f,%6.2f)
      EMFP (A)       = %8.2f
      IMFP (A)       = %8.2f
    -------------------------------------------
    """%(self.order,self.energy,self.coords[0],self.coords[1],self.coords[2],self.vdirec[0],self.vdirec[1],self.vdirec[2],self.emfp,self.imfp)
    return infostr

  def getmfpdata(self,ecs,ics):
    self.ecsind,self.emfp=ElScattCrossSec.findemfp(ecs,self.energy)
    self.imfp=ics.findimfp(self.energy)
    self.mfp=1./(1./self.emfp+1./self.imfp)
    return

  def updatecoords(self,dr):
    self.coords[0]=self.coords[0]+dr*self.vdirec[0]
    self.coords[1]=self.coords[1]+dr*self.vdirec[1]
    self.coords[2]=self.coords[2]+dr*self.vdirec[2]
    return

  def updatevdirecpolar(self,dtheta,dphi):
    self.vtheta=(self.vtheta+dtheta)%(2*np.pi)
    self.vphi=(self.vphi+dphi)%(2*np.pi)
    dx=np.sin(self.vtheta)*np.cos(self.vphi)
    dy=np.sin(self.vtheta)*np.sin(self.vphi)
    dz=np.cos(self.vtheta)
    self.vdirec[0]=dx
    self.vdirec[1]=dy
    self.vdirec[2]=dz
    return

  def updateenergy(self,denergy,stopenergy,ecsdata,icsinst):
    self.energy=self.energy+denergy
    self.getmfpdata(ecsdata,icsinst)
    self.stopped=self.energy<stopenergy
    return

  def checktransmit(self,Efermi,workfn,rand):
    U0=(Efermi+workfn)*ev2au
    vx=self.vdirec[0]
    vy=self.vdirec[1]
    vz=self.vdirec[2]
    beta=np.pi-self.vtheta
    Ecos2beta=self.energy*ev2au*np.cos(beta)*np.cos(beta)
    if Ecos2beta > U0:
     T=4.*np.sqrt(1.-U0/Ecos2beta)/(1.+np.sqrt(1.-U0/Ecos2beta))**2
    else:
     T=0.
    if rand < T: # transmit
     self.vtheta=np.arcsin(np.sqrt(self.energy/(self.energy-U0*au2ev))*np.sin(beta)) # self.vtheta is now angle from normal to -z axis
     self.energy=self.energy-U0*au2ev # no need to use updateenergy which looks up new MFP data
     self.transmitted=True
    else: # reflect
     delr=self.coords[2]/vz
     self.updatecoords(-delr) # move back to z=0 (negative displacement along same velocity)
     self.updatevdirecpolar(np.pi-2*self.vtheta,0.)
     self.updatecoords(delr) # move along new direction by remaining displacement
    return

  @staticmethod
  def prune(inst): # returns true if neither stopped nor transmitted (use with filter to prune lists of electrons)
    return not(inst.transmitted or inst.stopped)


def plotdata(data,filestring):
  """
  Writes tupled [data] to file with name [filestring] to cwd

  Inputs:
           data: list of tuples (x,y)
     filestring: name of file to construct

  Outputs:
     Writes file [filestring] to cwd with columned data (x,y)
  """
  contents=os.listdir(".")
  if filestring in contents:
   raise IOError("File " + filestring + " already in cwd")
  outp=open(filestring,"w")
  npts=len(data)
  for i in range(npts):
    outp.write("%20.10f%20.10f\n"%(data[i][0],data[i][1]))
  outp.close()
  return

def readparams(filestring):
  """
  Reads parameters from a file [filestring]

  Inputs:
     filestring: name of file to read

  Returns:
            Efermi: Fermi energy (eV)
           workfun: Work function (eV)
               en0: Primary electron energy (eV)
           coords0: Initial coordinates of electron (bohr)
            theta0: Initial angle to normal (rad)
              phi0: Initial azimuthal angule (rad)
     nprimaryelecs: Total number of primary electrons to simulate
     nelecpercycle: Number of primary electrons to simulate per MC cycle
       fdiffinelcs: Filename for inelastic cross section data
              felf: Filename for energy loss function data
          dirececs: Directory with elastic cross section data (e.g. *.D64 files)
             fimfp: Filename for inelastic mean free path data
  """
  try:
    inp=open(filestring,"r")
    lines=inp.readlines()
    inp.close()
  except:
    raise IOError("File " + filestring + " not found")
  Efermi=float(lines[0].strip().split()[0])
  del lines[0]
  workfn=float(lines[0].strip().split()[0])
  del lines[0]
  en0=float(lines[0].strip().split()[0])
  del lines[0]
  coords0=[float(lines[0].strip().split()[0]),float(lines[0].strip().split()[1]),float(lines[0].strip().split()[2])]
  del lines[0]
  theta0=float(lines[0].strip().split()[0])
  del lines[0]
  phi0=float(lines[0].strip().split()[0])
  del lines[0]
  nprimaryelecs=int(lines[0].strip().split()[0])
  del lines[0]
  nelecpercycle=int(lines[0].strip().split()[0])
  del lines[0]
  fdiffinelcs=lines[0].strip().split()[0]
  del lines[0]
  felf=lines[0].strip().split()[0]
  del lines[0]
  dirececs=lines[0].strip().split()[0]
  del lines[0]
  fimfp=lines[0].strip().split()[0]
  del lines[0]
  return Efermi,workfn,en0,coords0,theta0,phi0,nprimaryelecs,nelecpercycle,fdiffinelcs,felf,dirececs,fimfp

def runmccycle(elecs,ecsdata,ics,Efermi,workfn,stopen):
  """
  Runs a Monte Carlo cycle on an array of electrons [elecs] proceeding until all electrons transmitted or stopped

  Inputs:
       elecs: List of electron instances whose trajectories will be simulated by MC
     ecsdata: List of ElScattCrossSec instances containing elastic scattering data
         ics: InelScattCrossSec instance containing inelastic scattering data
      Efermi: Fermi energy (eV)
      workfn: Work function (eV)
      stopen: Energy threshold below which electron is considered to be stopped in material (eV)

  Returns:
            nstopped: Number of stopped electrons
        ntransmitted: Number of transmitted electrons
     nsectransmitted: Number of non-primary electrons transmitted
           emitteden: List of kinetic energies of transmitted electrons (eV)
  """
# Set up random number generators
  randarr=[]
  randarr.append(Random())
  randarr[0].seed()
  initstate=randarr[0].getstate()
  for i in range(1,8):
    randarr.append(Random())
    randarr[i].setstate(initstate)
    randarr[i].jumpahead(i*1000000001)

# Tabulate EMFP and IMFP energies
  ecsenergies=np.zeros(len(ecsdata))
  for i in range(len(ecsdata)):
    ecsenergies[i]=ecsdata[i].energy
  icsenergies=ics.getEcoords()

# Run MC cycle on elecs
  alldone=False
  ntransmitted=0
  nstopped=0
  emitteden=[]
  nsectransmitted=0
  while not alldone:
    secelecs=[]
#    eleccount=0

    for el in elecs:
#      eleccount+=1
#      print "Trajectory for electron: ",eleccount

# Determine length before scattering event
      rand1=randarr[0].random()
      s=-el.mfp*np.log(rand1)
      el.updatecoords(s)
#      print "Moving by: ",s
#      print el

# Check if transmitted if surface crossed (z<0)
      if el.coords[2] < 0:
       rand8=randarr[7].random()
       el.checktransmit(Efermi,workfn,rand8)
       if el.transmitted:
        ntransmitted+=1
        emitteden.append(el.energy)
        if el.energy <= 50:
         nsectransmitted+=1
        continue

# Determine type of scattering event
      rand2=randarr[1].random()
      if rand2 < el.mfp/el.emfp:
       elastic=True
      else:
       elastic=False

      if elastic:
# Elastic scattering: determine angles after scattering
       rand3=randarr[2].random()
       ecsintind,ecsintval=findnearest(ecsdata[el.ecsind].cumintdata,rand3*ecsdata[el.ecsind].totcrosssec/(2.*np.pi))
       dtheta=ecsdata[el.ecsind].data[ecsintind][0]

       rand4=randarr[3].random()
       dphi=2*np.pi*rand4

#       print "Elastic (dtheta,dphi):",dtheta*180/pi,dphi*180/pi
       el.updatevdirecpolar(dtheta,dphi)
#       print el

      else:
# Inelastic scattering: determine energy loss and angles after scattering
       icsind,icsval=findnearest(icsenergies,el.energy*ev2au)
       delEcoords=ics.getdelEcoords(icsval)
       rand5=randarr[4].random()
       icsintind,icsintval=findnearest(ics.cumintdata[icsind,:],rand5*ics.totcrosssec[icsind])
       delE=delEcoords[icsintind]

# Given E, delE, form probability distribution for double differential cross section
       rand6=randarr[5].random()
       wcoords=ics.getwcoords()
       icsind,icsval=findnearest(wcoords,delE)
       dtheta=ics.finddcsangle(el.energy*ev2au,delE,icsind,rand6)

       rand7=randarr[6].random()
       dphi=2*np.pi*rand7

#       print "Inelastic (delE,dtheta,dphi)",delE*au2ev,dtheta*180/pi,dphi*180/pi

       newen=delE*au2ev+Efermi
       if newen > stopen: # Only generate secondary electron if energy greater than stopped energy cutoff
        newel=Electron(el.order+1,delE*au2ev+Efermi,el.coords,el.vtheta,el.vphi,ecsdata,ics)
        newel.updatevdirecpolar(np.arcsin(np.cos(dtheta)),dphi+np.pi)
        secelecs.append(newel)

       el.updatevdirecpolar(dtheta,dphi)
       el.updateenergy(-delE*au2ev,stopen,ecsdata,ics)
       if el.stopped:
        nstopped+=1
#       print el
#       print newel

    elecs[:]=filter(Electron.prune,elecs) # This syntax will ensure elecs is modified in place (affects calling routines referencing elecs as well!)
    elecs.extend(secelecs)
#    print "Number of electrons, Number of stopped electrons, Number of transmitted electrons:",len(elecs),nstopped,ntransmitted
    alldone=elecs==[]

  return nstopped,ntransmitted,nsectransmitted,emitteden


if __name__ == "__main__":
 currdir=os.getcwd()

# Read system parameters
 Efermi,workfn,en0,coords0,theta0,phi0,nprimaryelecs,junk,fdiffinelcs,felf,decs,fimfp=readparams("params.in")
 stopen=Efermi+workfn # elecs with less than this energy cannot be transmitted

 os.chdir(decs)
 contents=os.listdir(".")
 ecsdata=[]
 for item in contents:
   cs=ElScattCrossSec(item)
#   print cs.atnum,cs.energy,cs.totcrosssec,2.*pi*cs.nintegrate(0,pi),2.*pi*cs.cumintdata[-1],cs.emfp
   ecsdata.append(cs)

 os.chdir(currdir)
 ics=InelScattCrossSec(fimfp)
# print ics.atnum,ics.atweight,ics.density
# plotdata(ics.imfpdata,"imfp_vs_E.dat")
 ics.readicsdata(fdiffinelcs,felf,Efermi)
# print ics.Emin,ics.Emax,ics.NE,ics.NdelE
# print ics.Emin*au2ev,ics.Emax*au2ev,ics.Nw,ics.wmin*au2ev,ics.wmax*au2ev,ics.Nq,ics.qmin*ang2bohr,ics.qmax*ang2bohr,ics.maxang

 elecs=[]
 for i in range(nprimaryelecs):
   elecs.append(Electron(0,en0,coords0,theta0,phi0,ecsdata,ics))
 nstopped,ntransmitted,nsectransmitted,emitteden=runmccycle(elecs,ecsdata,ics,Efermi,workfn,stopen)
 emitteden.sort()

 outp=open("emitted_energies.dat","w")
 outp.write(str(nprimaryelecs) + " # Number of primary electrons\n")
 outp.write(str(nstopped) + " # Number of stopped electrons\n")
 outp.write(str(ntransmitted) + " # Number of transmitted electrons\n")
 outp.write(str(nsectransmitted) + " # Number of transmitted true secondary electrons\n")
 for i in range(len(emitteden)):
   outp.write("%10.6f\n"%(emitteden[i]))
 outp.close()

